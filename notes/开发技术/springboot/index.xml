<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpringBoot on 小桀的笔记本</title>
    <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/</link>
    <description>Recent content in SpringBoot on 小桀的笔记本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy;{year}, All Rights Reserved</copyright>
    
        <atom:link href="http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>Actuator</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/actuator/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/actuator/</guid>
        <description></description>
      </item>
      
      <item>
        <title>application.yml</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/application.yml/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/application.yml/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Spring</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/spring/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/spring/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Spring MVC</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/spring-mvc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/spring-mvc/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Validation</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/validation/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/validation/</guid>
        <description></description>
      </item>
      
      <item>
        <title>@AutoConfigurationPackage注解的意义</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/autoconfigurationpackage%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%84%8F%E4%B9%89/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/autoconfigurationpackage%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%84%8F%E4%B9%89/</guid>
        <description>AutoConfigurationPackage注解代码如下： 1 2 3 4 @Import(AutoConfigurationPackages.Registrar.class) public @interface AutoConfigurationPackage {} 这个注解的功能是： 利用Register给容器导入一系列组件 将</description>
      </item>
      
      <item>
        <title>@Bean配置时一段经典的源码</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/bean%E9%85%8D%E7%BD%AE%E6%97%B6%E4%B8%80%E6%AE%B5%E7%BB%8F%E5%85%B8%E7%9A%84%E6%BA%90%E7%A0%81/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/bean%E9%85%8D%E7%BD%AE%E6%97%B6%E4%B8%80%E6%AE%B5%E7%BB%8F%E5%85%B8%E7%9A%84%E6%BA%90%E7%A0%81/</guid>
        <description>如下代码： 1 2 3 4 5 6 7 8 @Bean @ConditionalOnBean(MultipartResolver.class) @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) public MultipartResolver multipartResolver(MultipartResolver resolver) { return resolver; } 这段配置的含义是这样的，如果容器中有dispatcherServlet的bean，容器中</description>
      </item>
      
      <item>
        <title>@EnableFeignClients中没有配置backPackages，导致找不到客户端</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/enablefeignclients%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AEbackpackages%E5%AF%BC%E8%87%B4%E6%89%BE%E4%B8%8D%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/enablefeignclients%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AEbackpackages%E5%AF%BC%E8%87%B4%E6%89%BE%E4%B8%8D%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
        <description>我的客户端放在com.sdstc.auth.client下，我代码的包结构如下： 默认情况下，我需要将我的启动类放在com.sdstc下才能够</description>
      </item>
      
      <item>
        <title>Converter与Formatter</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/converter%E4%B8%8Eformatter/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/converter%E4%B8%8Eformatter/</guid>
        <description>Converter是通用元件，可以将一种类型转换成另一种类型，可以在应用程序中的任意层使用。 Formatter只能将String转换成另一种</description>
      </item>
      
      <item>
        <title>Feign客户端的返回值和Controller的返回值之间没有强约束</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/feign%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8Ccontroller%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B9%8B%E9%97%B4%E6%B2%A1%E6%9C%89%E5%BC%BA%E7%BA%A6%E6%9D%9F/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/feign%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8Ccontroller%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B9%8B%E9%97%B4%E6%B2%A1%E6%9C%89%E5%BC%BA%E7%BA%A6%E6%9D%9F/</guid>
        <description>事情是这样的，我用entity包下的Company开发了一个Controller，但是我FeignClient返回的是response包下C</description>
      </item>
      
      <item>
        <title>Feign抛出了异常，及异常的处理</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/feign%E6%8A%9B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/feign%E6%8A%9B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</guid>
        <description>如下代码为我们框架中自己开发的Decoder： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Slf4j public class FeignDecoder extends SpringDecoder { public FeignDecoder(ObjectFactory&amp;lt;HttpMessageConverters&amp;gt; messageConverters) { super(messageConverters); } @Override public Object decode(final Response response, Type type) throws</description>
      </item>
      
      <item>
        <title>Idea中无法跳转到spring-boot-starter-parent源码了</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/idea%E4%B8%AD%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E5%88%B0spring-boot-starter-parent%E6%BA%90%E7%A0%81%E4%BA%86/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/idea%E4%B8%AD%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E5%88%B0spring-boot-starter-parent%E6%BA%90%E7%A0%81%E4%BA%86/</guid>
        <description>想看一下spring-boot-starter-parent的源码，看看版本裁决时用了哪些变量，但是发现Idea无法调整到这些源码，这就很奇</description>
      </item>
      
      <item>
        <title>Method has too many Body parameters</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/method-has-too-many-body-parameters/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/method-has-too-many-body-parameters/</guid>
        <description>问题描述 报错如下： Caused by: java.lang.IllegalStateException: Method has too many Body parameters: public abstract void com.sdstc.authcenter.client.UserConfigClient.updateUserListConfig(java.lang.String,com.sdstc.authcenter.request.UpdateListConfigRequest) at feign.Util.checkState(Util.java:127) ~[feign-core-10.1.0.jar:?] at feign.Contract$BaseContract.parseAndValidateMetadata(Contract.java:117) ~[feign-core-10.1.0.jar:?] at org.springframework.cloud.openfeign.support.SpringMvcContract.parseAndValidateMetadata(SpringMvcContract.java:188) ~[spring-cloud-openfeign-core-2.1.1.RELEASE.jar:2.1.1.RELEASE] at feign.Contract$BaseContract.parseAndValidatateMetadata(Contract.java:66) ~[feign-core-10.1.0.jar:?] at feign.ReflectiveFeign$ParseHandlersByName.apply(ReflectiveFeign.java:154) ~[feign-core-10.1.0.jar:?] at feign.ReflectiveFeign.newInstance(ReflectiveFeign.java:52) ~[feign-core-10.1.0.jar:?] at feign.Feign$Builder.target(Feign.java:251) ~[feign-core-10.1.0.jar:?] at org.springframework.cloud.openfeign.HystrixTargeter.target(HystrixTargeter.java:36) ~[spring-cloud-openfeign-core-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.cloud.openfeign.FeignClientFactoryBean.getTarget(FeignClientFactoryBean.java:284) ~[spring-cloud-openfeign-core-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.cloud.openfeign.FeignClientFactoryBean.getObject(FeignClientFactoryBean.java:247) ~[spring-cloud-openfeign-core-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:171) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:101) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1818) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getObjectForBeanInstance(AbstractAutowireCapableBeanFactory.java:1266) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:260) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]</description>
      </item>
      
      <item>
        <title>RequestParam缺少参数，导致FeignClient注入失败</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/requestparam%E7%BC%BA%E5%B0%91%E5%8F%82%E6%95%B0%E5%AF%BC%E8%87%B4feignclient%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/requestparam%E7%BC%BA%E5%B0%91%E5%8F%82%E6%95%B0%E5%AF%BC%E8%87%B4feignclient%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/</guid>
        <description>今天我在Feign Client中增加了如下的代码： 1 2 3 4 5 6 7 /** * 全量获取材料平台供应商列表（SRM） */ @GetMapping(&amp;#34;getSupplierById&amp;#34;) SupplierResponse getSupplierById(@RequestParam String supplierId); 结果本地安装后，会导致依</description>
      </item>
      
      <item>
        <title>SpringBoot依赖版本被覆盖</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E8%A2%AB%E8%A6%86%E7%9B%96/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E8%A2%AB%E8%A6%86%E7%9B%96/</guid>
        <description>因为开发需求，引入了如下一些包： 1 2 3 4 5 6 7 8 9 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.sdstc.starter&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;elasticjob-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 结果项目无法正常启动，报如下错误： *************************** APPLICATION FAILED TO START *************************** Description: An attempt was made to call a method that does not exist. The attempt</description>
      </item>
      
      <item>
        <title>SpringBoot修改默认的时区</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E6%97%B6%E5%8C%BA/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E6%97%B6%E5%8C%BA/</guid>
        <description>代码如下： 1 2 3 4 5 6 @PostConstruct void setDefaultTimezone() { TimeZone.setDefault(TimeZone.getTimeZone(&amp;#34;GMT&amp;#34;)); } 需要注意的是如下的写法并不会生效： 1 2 3 4 5 6 public static void main(String[] args) { TimeZone.setDefault(TimeZone.getTimeZone(&amp;#34;GMT&amp;#34;)); SpringApplication.run(MybatisApplication.class, args); } 查看当前实例的时区，可用如下代码： 1 2 3</description>
      </item>
      
      <item>
        <title>SpringBoot在代码中获取profiles信息</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%8E%B7%E5%8F%96profiles%E4%BF%A1%E6%81%AF/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%8E%B7%E5%8F%96profiles%E4%BF%A1%E6%81%AF/</guid>
        <description>方案都挺不优雅的，尤其是在激活多个profiles时，先收集一下，下次用的时候再整理吧。 参考资料 SpringBoot获取当前运行环境三种方式</description>
      </item>
      
      <item>
        <title>SpringBoot容器初始化后执行回调</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83/</guid>
        <description>使用场景是这样的，一个记录配置信息的类，想使用静态方法、静态字段记录一些存储在配置文件中的信息。我选择定义这些静态的字段，然后再定义一些需要</description>
      </item>
      
      <item>
        <title>SpringBoot的@Configuration配置</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E7%9A%84configuration%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E7%9A%84configuration%E9%85%8D%E7%BD%AE/</guid>
        <description>@Configuration的proxyBeanMethods参数 entity包 User.java 1 2 3 4 5 6 7 @NoArgsConstructor @AllArgsConstructor public class User { private String name; } Pet.java 1 2 3 4 5 6 7 @NoArgsConstructor @AllArgsConstructor public class</description>
      </item>
      
      <item>
        <title>SpringBoot获取Bean</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E8%8E%B7%E5%8F%96bean/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E8%8E%B7%E5%8F%96bean/</guid>
        <description>其实相关的技术我很早前就用在了项目中，但是一直没有整理笔记，最近在重构我工具包的代码时，又使用到了相关的技术，所以顺便整理一下。我工具包有个</description>
      </item>
      
      <item>
        <title>SpringBoot获取当前运行环境</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springboot%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</guid>
        <description>我们一部分接口在local环境并调不通，我将这些接口写在了manage层，我希望我有个开关当我在本地环境运行的时候，这些接口可以不被调用，我</description>
      </item>
      
      <item>
        <title>SpringCloud使用Feign方案</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springcloud%E4%BD%BF%E7%94%A8feign%E6%96%B9%E6%A1%88/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/springcloud%E4%BD%BF%E7%94%A8feign%E6%96%B9%E6%A1%88/</guid>
        <description>操作步骤 如图两个项目mmp-wuid和mmp-member-brand项目 mmp-wuid项目下有如下module，其中admin、api、</description>
      </item>
      
      <item>
        <title>Starter的命名习惯</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/starter%E7%9A%84%E5%91%BD%E5%90%8D%E4%B9%A0%E6%83%AF/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/starter%E7%9A%84%E5%91%BD%E5%90%8D%E4%B9%A0%E6%83%AF/</guid>
        <description>官方的starter命名：spring-boot-starter-* 第三方的starter命名：*-spring-boot-starter M</description>
      </item>
      
      <item>
        <title>不开启feign客户端，就无法使用oss签名功能</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E4%B8%8D%E5%BC%80%E5%90%AFfeign%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8oss%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E4%B8%8D%E5%BC%80%E5%90%AFfeign%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8oss%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/</guid>
        <description>其实这个问题不值得记录，但是实在是太巧合了，我刚修复好这个问题，另一个同事也遇到了，所以我就直接告诉他怎么修复了，他解决这个问题所花费的时间</description>
      </item>
      
      <item>
        <title>从Header中获取值</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E4%BB%8Eheader%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%80%BC/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E4%BB%8Eheader%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%80%BC/</guid>
        <description>代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 硬件校准信息上报 */ @PostMapping(&amp;#34;/client/calibration/report&amp;#34;) @PassToken public ResponseVo&amp;lt;Object&amp;gt; clientCalibrationReport( @RequestHeader(value = &amp;#34;terminal&amp;#34;) Integer terminal, @Valid @RequestBody ClientCalibrationReportRequest request) { clientCalibrationReportService.saveClientCalibrationReport(terminal, request); return ResponseVo.createSuccess(); } 参考资料 java 获取HttpRequest Header</description>
      </item>
      
      <item>
        <title>从请求到入库都使用枚举</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%88%B0%E5%85%A5%E5%BA%93%E9%83%BD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%88%B0%E5%85%A5%E5%BA%93%E9%83%BD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE/</guid>
        <description>核心的目标是，用户传递的某个字段的值，在@RequestBody转换后，自动转换成枚举，因为枚举是全局的，所以可以直接赋值给entity的相</description>
      </item>
      
      <item>
        <title>包扫描位置指定错误，导致无法进入自定义Intercepter</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E5%8C%85%E6%89%AB%E6%8F%8F%E4%BD%8D%E7%BD%AE%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89intercepter/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E5%8C%85%E6%89%AB%E6%8F%8F%E4%BD%8D%E7%BD%AE%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89intercepter/</guid>
        <description>公司开新项目，我参考以往的代码起了一个项目，项目启动很成功，但是请求时报如下错误： 我们开发了相应的拦截器，负责解析请求中传递的token，将</description>
      </item>
      
      <item>
        <title>缺乏父依赖，导致项目报Redis链接错误</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E7%BC%BA%E4%B9%8F%E7%88%B6%E4%BE%9D%E8%B5%96%E5%AF%BC%E8%87%B4%E9%A1%B9%E7%9B%AE%E6%8A%A5redis%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E7%BC%BA%E4%B9%8F%E7%88%B6%E4%BE%9D%E8%B5%96%E5%AF%BC%E8%87%B4%E9%A1%B9%E7%9B%AE%E6%8A%A5redis%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</guid>
        <description>具体报Redis的错误我忘记整理了，但是该错误我曾经遇到过，如下（日志来自另一篇笔记）： java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:123) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) at</description>
      </item>
      
      <item>
        <title>配置Idea初始化SpringBoot项目时使用阿里的源</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E9%85%8D%E7%BD%AEidea%E5%88%9D%E5%A7%8B%E5%8C%96springboot%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E7%9A%84%E6%BA%90/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E9%85%8D%E7%BD%AEidea%E5%88%9D%E5%A7%8B%E5%8C%96springboot%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E7%9A%84%E6%BA%90/</guid>
        <description>Idea初始化项目时使用阿里的源： https://start.aliyun.com/ 该怎么用，懂得都懂，:) 默认的是： https://start.spring.io</description>
      </item>
      
      <item>
        <title>错将@RequestParam写成@Param导致Feign无法正常返回数据</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E9%94%99%E5%B0%86requestparam%E5%86%99%E6%88%90param%E5%AF%BC%E8%87%B4feign%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E9%94%99%E5%B0%86requestparam%E5%86%99%E6%88%90param%E5%AF%BC%E8%87%B4feign%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</guid>
        <description>问题就如标题描述的一样，错误的将@RequestParam写成了@Param，最终导致Controller拿不到相应的参数，最终导致接口返回</description>
      </item>
      
      <item>
        <title>错将JSONObject写成JsonObject了</title>
        <link>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E9%94%99%E5%B0%86jsonobject%E5%86%99%E6%88%90jsonobject%E4%BA%86/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://junjie2018.github.io/notes/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/springboot/%E9%94%99%E5%B0%86jsonobject%E5%86%99%E6%88%90jsonobject%E4%BA%86/</guid>
        <description>是这样的，我参考之前的写法，在Request对象中用JSONObject去接受了前端请求传递了一个对象（我并不关心这个对象的结构）。结果接口</description>
      </item>
      
    
  </channel>
</rss>